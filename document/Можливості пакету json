JSON(JavaScript Object Notation) – це легкий формат обміну даними який синтаксисом схожий до JavaScript проте не є його підмножиною. Цей пакет виставляє API який є знайомий користувачам бібліотека модулів marshal i pickle. Модуль Json завжди продукує елементи типу string а не байтові обєкти.
JSON знайшов своє головне призначення у написанні веб-програм, а саме при використанні технології AJAX. JSON, що використовується в AJAX, виступає як заміна XML (використовується в AJAX) під час асинхронної передачі структурованої інформації між клієнтом та сервером.
При цьому перевагою JSON перед XML є те, що він дозволяє складні структури в атрибутах, займає менше місця і прямо інтерпретується за допомогою JavaScript в об'єкти.
В обнові 3.2 Є дозволеним рядки для відступу в додачу до цілих чисел. Якщо вказано, сепаратори повинні бути (item_separator, key_separator) типу кортеж. За замовчуванням ( '', ':'), якщо відступи не є значення None і ( ',', ':') в іншому випадку.
Щоб отримати найбільш компактне представлення JSON, слід вказати ( «», «:») для усунення пустих місць. Якщо вказано, за замовчуванням повинна бути функція, яка викликається для об'єктів, які не можуть бути серіалізовать. Він повинен повертати кодовану версію JSON об'єкта або викликати  TypeError. Якщо не вказано, TypeError випливає.
Кодування і декодування:
По стандарту відбувається такий переклад.

parse_float, якщо вказано, буде викликатися з рядка кожного JSON float буде  розшифрованим. За замовчуванням, це еквівалентно плаваючим (num_str). Це може бути використано, щоб використовувати інший тип даних або аналізатор для JSON float (наприклад, decimal.Decimal).
parse_int, якщо вказано, буде викликатися з string кожного JSON цілого для декодування. За замовчуванням, це еквівалентно int (num_str). Це може бути використано, щоб використовувати інший тип даних або аналізатор для JSON цілих чисел з плаваючою точкою (наприклад).
parse_constant, якщо вказано, буде називатися однією з наступних рядків: «-Infinity», «нескінченність», «NaN». Це може бути використано для згенерує виняток, якщо недійсні числа JSON зустрічаються.
Змінено в версії 3.2: Дозволити рядки для відступу в доповненні до цілих чисел
Якщо вказано, сепаратори повинні бути (item_separator, key_separator) кортежами. За замовчуванням ( '', ':'), якщо відступи не є None, і ( ',', ':') в іншому випадку. Щоб отримати найбільш компактне представлення про JSON, слід вказати ( «», «:») для усунення прогалин.
Змінено в версії 3.4: Використовуйте ( «», «:») за замовчуванням, якщо відступи не є None.
Якщо вказано, за замовчуванням повинна бути функція , яка викликається для об'єктів, які не можуть бути серіалізовані. Вона повинна повертати кодовану версію JSON об'єкта або підняти TypeError. Якщо не вказано, TypeError викликається.
Наприклад, для підтримки довільних ітераторів, ви могли б реалізувати за замовчуванням, як це:
def default(self, o):
   try:
       iterable = iter(o)
   except TypeError:
       pass
   else:
       return list(iterable)
   # Let the base class default method raise the TypeError
   return json.JSONEncoder.default(self, o)
encode(o)
Повертає строкове представлення JSON структури даних Python, о. Наприклад:
>>>
>>> json.JSONEncoder () кодують ({ "Foo": [ "бар", "Баз"]}).
'{ "Foo": [ "бар", "Баз"]}'
iterencode (о)
Відповідність стандартам і функціональна сумісність
Формат JSON задається RFC 7159 і ECMA-404. У цьому розділі докладно рівень цього модуля відповідно до RFC. Для простоти, JSONEncoder і JSONDecoder підкласів, і, крім тих, які явно зазначених параметрів, не розглядається. Цей модуль не відповідає RFC в строгому чином, реалізуючи деякі розширення, які є дійсним JavaScript, але не дійсний JSON.
FC вимагає, щоб JSON бути представлені з використанням або UTF-8, UTF-16 або UTF-32, з UTF-8, будучи рекомендований за замовчуванням для максимальної сумісності.
RFC забороняє додавання мітки порядку байтів (BOM) на початку тексту JSON і серіалізатор цього модуля не додає BOM до його виходу.
JSON(JavaScript Object Notation) – це легкий формат обміну даними який синтаксисом схожий до JavaScript проте не є його підмножиною. Цей пакет виставляє API який є знайомий користувачам бібліотека модулів marshal i pickle. Модуль Json завжди продукує елементи типу string а не байтові обєкти.
В обнові 3.2 Є дозволеним рядки для відступу в додачу до цілих чисел. Якщо вказано, сепаратори повинні бути (item_separator, key_separator) типу кортеж. За замовчуванням ( '', ':'), якщо відступи не є значення None і ( ',', ':') в іншому випадку. Щоб отримати найбільш компактне представлення JSON, слід вказати ( «», «:») для усунення пустих місць. Якщо вказано, за замовчуванням повинна бути функція, яка викликається для об'єктів, які не можуть бути серіалізовать. Він повинен повертати кодовану версію JSON об'єкта або викликати  TypeError. Якщо не вказано, TypeError випливає.
Кодування і декодування:
По стандарту відбувається такий переклад.

parse_float, якщо вказано, буде викликатися з рядка кожного JSON float буде  розшифрованим. За замовчуванням, це еквівалентно плаваючим (num_str). Це може бути використано, щоб використовувати інший тип даних або аналізатор для JSON float (наприклад, decimal.Decimal).
parse_int, якщо вказано, буде викликатися з string кожного JSON цілого для декодування. За замовчуванням, це еквівалентно int (num_str). Це може бути використано, щоб використовувати інший тип даних або аналізатор для JSON цілих чисел з плаваючою точкою (наприклад).
parse_constant, якщо вказано, буде називатися однією з наступних рядків: «-Infinity», «нескінченність», «NaN». Це може бути використано для згенерує виняток, якщо недійсні числа JSON зустрічаються.
Змінено в версії 3.2: Дозволити рядки для відступу в доповненні до цілих чисел
Якщо вказано, сепаратори повинні бути (item_separator, key_separator) кортежами. За замовчуванням ( '', ':'), якщо відступи не є None, і ( ',', ':') в іншому випадку. Щоб отримати найбільш компактне представлення про JSON, слід вказати ( «», «:») для усунення прогалин.
Змінено в версії 3.4: Використовуйте ( «», «:») за замовчуванням, якщо відступи не є None.
Якщо вказано, за замовчуванням повинна бути функція , яка викликається для об'єктів, які не можуть бути серіалізовані. Вона повинна повертати кодовану версію JSON об'єкта або підняти TypeError. Якщо не вказано, TypeError викликається.
Наприклад, для підтримки довільних ітераторів, ви могли б реалізувати за замовчуванням, як це:
def default(self, o):
   try:
       iterable = iter(o)
   except TypeError:
       pass
   else:
       return list(iterable)
   # Let the base class default method raise the TypeError
   return json.JSONEncoder.default(self, o)
encode(o)
Повертає строкове представлення JSON структури даних Python, о. Наприклад:
>>>
>>> json.JSONEncoder () кодують ({ "Foo": [ "bar", "Baz"]}).
'{ "Foo": [ "bar", "Baz"]}'
iterencode (о)
Відповідність стандартам і функціональна сумісність
Формат JSON задається RFC 7159 і ECMA-404. У цьому розділі докладно рівень цього модуля відповідно до RFC. Для простоти, JSONEncoder і JSONDecoder підкласів, і, крім тих, які явно зазначених параметрів, не розглядається. Цей модуль не відповідає RFC в строгому чином, реалізуючи деякі розширення, які є дійсним JavaScript, але не дійсний JSON.
FC вимагає, щоб JSON бути представлені з використанням або UTF-8, UTF-16 або UTF-32, з UTF-8, будучи рекомендований за замовчуванням для максимальної сумісності.
RFC забороняє додавання мітки порядку байтів (BOM) на початку тексту JSON і серіалізатор цього модуля не додає BOM до його виходу.
JSON(JavaScript Object Notation) – це легкий формат обміну даними який синтаксисом схожий до JavaScript проте не є його підмножиною. Цей пакет виставляє API який є знайомий користувачам бібліотека модулів marshal i pickle. Модуль Json завжди продукує елементи типу string а не байтові обєкти.
В обнові 3.2 Є дозволеним рядки для відступу в додачу до цілих чисел. Якщо вказано, сепаратори повинні бути (item_separator, key_separator) типу кортеж. За замовчуванням ( '', ':'), якщо відступи не є значення None і ( ',', ':') в іншому випадку. Щоб отримати найбільш компактне представлення JSON, слід вказати ( «», «:») для усунення пустих місць. Якщо вказано, за замовчуванням повинна бути функція, яка викликається для об'єктів, які не можуть бути серіалізовать. Він повинен повертати кодовану версію JSON об'єкта або викликати  TypeError. Якщо не вказано, TypeError випливає.
Кодування і декодування:
По стандарту відбувається такий переклад.

parse_float, якщо вказано, буде викликатися з рядка кожного JSON float буде  розшифрованим. За замовчуванням, це еквівалентно плаваючим (num_str). Це може бути використано, щоб використовувати інший тип даних або аналізатор для JSON float (наприклад, decimal.Decimal).
parse_int, якщо вказано, буде викликатися з string кожного JSON цілого для декодування. За замовчуванням, це еквівалентно int (num_str). Це може бути використано, щоб використовувати інший тип даних або аналізатор для JSON цілих чисел з плаваючою точкою (наприклад).
parse_constant, якщо вказано, буде називатися однією з наступних рядків: «-Infinity», «нескінченність», «NaN». Це може бути використано для згенерує виняток, якщо недійсні числа JSON зустрічаються.
Змінено в версії 3.2: Дозволити рядки для відступу в доповненні до цілих чисел
Якщо вказано, сепаратори повинні бути (item_separator, key_separator) кортежами. За замовчуванням ( '', ':'), якщо відступи не є None, і ( ',', ':') в іншому випадку. Щоб отримати найбільш компактне представлення про JSON, слід вказати ( «», «:») для усунення прогалин.
Змінено в версії 3.4: Використовуйте ( «», «:») за замовчуванням, якщо відступи не є None.
Якщо вказано, за замовчуванням повинна бути функція , яка викликається для об'єктів, які не можуть бути серіалізовані. Вона повинна повертати кодовану версію JSON об'єкта або підняти TypeError. Якщо не вказано, TypeError викликається.
Наприклад, для підтримки довільних ітераторів, ви могли б реалізувати за замовчуванням, як це:
def default(self, o):
   try:
       iterable = iter(o)
   except TypeError:
       pass
   else:
       return list(iterable)
   # Let the base class default method raise the TypeError
   return json.JSONEncoder.default(self, o)
encode(o)
Повертає строкове представлення JSON структури даних Python, о. Наприклад:
>>>
>>> json.JSONEncoder () кодують ({ "Foo": [ "bar", "Baz"]}).
'{ "Foo": [ "bar", "Baz"]}'
iterencode (о)
Відповідність стандартам і функціональна сумісність
Формат JSON задається RFC 7159 і ECMA-404. У цьому розділі докладно рівень цього модуля відповідно до RFC. Для простоти, JSONEncoder і JSONDecoder підкласів, і, крім тих, які явно зазначених параметрів, не розглядається. Цей модуль не відповідає RFC в строгому чином, реалізуючи деякі розширення, які є дійсним JavaScript, але не дійсний JSON.
FC вимагає, щоб JSON бути представлені з використанням або UTF-8, UTF-16 або UTF-32, з UTF-8, будучи рекомендований за замовчуванням для максимальної сумісності.
RFC забороняє додавання мітки порядку байтів (BOM) на початку тексту JSON і серіалізатор цього модуля не додає BOM до його виходу.
